#include <string.h>
#include "compat.h"
#include "trajectory.h"
#include "distance.h"


void local_best_paths(  Node  *graph,  int sz,
                        Node **source, int nsource )
/*
  * Local Bipartite matching
  * - full bipartite matching of all nodes to themselves takes too long.
  * - solution is to first limit the graph to reasonable connections
  *   - start with orphan nodes as sources
  *   - compute the set of nodes generated by a one connection jump, set
  *     as dest
  *   - compute bipartite matching between sources and dest
  *   - prune all edges from sources that don't comply with the matching
  *   - set dest as sources and repeat till no more dest.
  *
  */
{ Node *map, **dest;
  int ndest,nmap;
  int i;

  /* find optimal mapping from set of source nodes to set of nodes 1 jump
   * downstream
   * */
  Get_Next_Nodes( graph, sz, source, nsource, &dest, &ndest);
  if( !ndest )
    return;

  map = Bipartite_Matching( source, nsource, dest, ndest, graph, sz, distance_pairwise );
  nmap = nsource + ndest;
  
  /* remove all edges from source nodes that don't comply with map */
  { Node *a,*b;
    Edge *e, *e0;
    for( i=0; i<nsource; i++ )
    { if( map[i].e )
      { a = (Node*)map[i].data;            /* the data are nodes of the trajectory graph */
        b = (Node*)map[i].e->sink->data;
        e0 = a->e;
        /* FIXME: what to do if e0 == NULL */
        /* This happens because the bipartite matching suggests a pairing
         * not in the original trajectory graph...why would this happen? 
         *
         * Even more...I think this only happens when the node has no outgoing
         * edges.  This means there should be nothing to do... 
         */
        if( !e0 )
          continue;
        e = e0->next;
        while( e && (e != e0) )
        { if( e->sink == b )
            e = e->next;
          else
            e = Prune_Edge(e);
        }
      } // end if map->e
    } // end for
  } //end context - remove edges

  free(dest);
  Get_Next_Nodes( graph, sz, source, nsource, &dest, &ndest);
  
  printf("Local best path - moving to next frame with %d nodes.\n", ndest );
  local_best_paths( graph, sz, dest, ndest );
  free(map);
  free(dest);
}

void get_forsaken( Node *graph,       int sz, 
                   Node ***orphans,   int *norphans,
                   Node ***childless, int *nchildless)
{ int i;
  Node **o, **c;
  int io = 0, ic = 0;
  Compute_InDegree( graph, sz );
  /* count */
  for( i=0; i<sz; i++ ) 
  { if( graph[i].indegree == 0 && ((Whisker_Seg*)graph[i].data)->time < 10 )
      (*norphans)++;
    else if( !graph[i].e  && ((Whisker_Seg*)graph[i].data)->time > 400 )  /* HACK */
      (*nchildless)++;
  }

  /* collect */
  o = (Node**) Guarded_Malloc( sizeof(Node*)*(*norphans  ), "Allocate orphans " );
  c = (Node**) Guarded_Malloc( sizeof(Node*)*(*nchildless), "Allocate children" );

  for( i=0; i<sz; i++ ) 
  { if( graph[i].indegree == 0 )
      o[io++] = graph+i;
    else if( !graph[i].e )
      c[ic++] = graph+i;
  }

  /* output */
  (*orphans)   = o;
  (*childless) = c;
  return;
}


void output_trajectory_tofile(void *arg, Edge **path, int depth, int path_id)
/* Note: Need a path of edges if one is going to record the edge score.      */
/*       This can cause a problem outputing the boundaries of a path         */
{ FILE *file = (FILE*)arg;
  Whisker_Seg *w;
  int i,last=-1;

  //progress("Writing path: %d\n",path_id);
  for(i=0;i<depth;i++)
  { if(path[i])
    { last = i;
      if(path[i]->source->type == (int) NL_WHISKER_SEG )
      { w = (Whisker_Seg*) path[i]->source->data;
        if(w)
          fprintf(file, "%d,%d,%d,%g\n", path_id, i, w->id, path[i]->score);
      }
    }
  }
  /* output the end of the path */
  if(last>=0)
  { if( path[last]->sink->type == (int) NL_WHISKER_SEG )
    { w = (Whisker_Seg*) path[last]->sink->data;
      if(w)
        fprintf(file, "%d,%d,%d,%g\n", path_id, last+1, w->id, 0.0);
    }
  }
}

int follow_all_edges(  int path_id, Node* root, 
                        Edge** path, int depth, 
                        void *arg, void (*output_func)(void*,Edge**,int,int) ) 
/* Traverses a directed acyclic graph from root enumerateing all paths from  */
/* root through the graph.                                                   */
{ int time = ((Whisker_Seg *) root->data)->time;
  Edge *e = root->e; 
  
  //progress("Time: %-4d Path: %d\n",time,path_id);

  /* output if at end of path */
  if( !e )
  { output_func(arg, path, depth, path_id );
    free(path);
    return path_id+1;
  }

  /* record */
  path[time] = e;
 
  /* spawn */
  follow_all_edges( path_id++, root->e->sink, path, depth, arg, output_func ); 
  for( e = root->e->next; e != root->e; e = e->next )
  { Edge **branch = (Edge**) Guarded_Malloc( depth*sizeof(Edge*), "branch in follow_all_edges" );
    memcpy( branch, path, depth*sizeof(Edge*) );
    follow_all_edges( path_id++, e->sink, branch, depth, arg, output_func );
  }
  return path_id; // ?
}

int  follow_minimal_edge_val(int path_id, Node* root, 
                             Edge** path, int depth, 
                             void *arg, void (*output_func)(void*,Edge**,int,int) )
{ int time = ((Whisker_Seg *) root->data)->time;
  Edge *e, *best;
  double bestd;

  /* output if at end of path */
  if( !(root->e) )
  { output_func(arg, path, depth, path_id );
    free(path);
    return path_id+1;
  }

  /* find edge with smallest score*/
  best = root->e;
  bestd = root->e->sink->val;  
  for( e = root->e->next; e != root->e; e = e->next )
  { if( bestd > e->sink->val   )
    { bestd = e->sink->val;  
      best = e;
    }
  } /*already did the one to grow on*/

  path[time] = best;   
  return follow_minimal_edge_val( path_id, best->sink, path, depth, arg, output_func );
}

int  follow_minimal_edge_score(int path_id, Node* root, 
                               Edge** path, int depth, 
                               void *arg, void (*output_func)(void*,Edge**,int,int) )
{ int time;
  Edge *e, *best;
  double bestd;

  if( root->type == (int) NL_LOST )
    time = (int) root->data;
  else
    time = ((Whisker_Seg *) root->data)->time; 

  /* output if at end of path */
  if( !(root->e) )
  { output_func(arg, path, depth, path_id );
    free(path);
    return path_id+1;
  }

  /* find edge with smallest score*/
  best = root->e;
  bestd = root->e->score;  
  for( e = root->e->next; e != root->e; e = e->next )
  { if( bestd > e->score       )
    { bestd = e->score;      
      best = e;
    }
  } /*already did the one to grow on*/

  path[time] = best;   
  return follow_minimal_edge_score( path_id, best->sink, path, depth, arg, output_func );
}

int  follow_best_incoming     ( int path_id, Node* root, 
                                Edge** path, int depth, 
                                void *arg, void (*output_func)(void*,Edge**,int,int) )
/* this one's kind of funny because rather than going forward in time, it
 * traces the path backwards.  The root is the end of the path.
 * And there's no branching.
 */
{ int time = ((Whisker_Seg *) root->data)->time;
  Edge *e = root->best_incoming;

  /* output if at beg of path */
  if( !e )
  { output_func(arg, path, depth, path_id );
    free(path);
    return path_id+1;
  }

  path[time] = e;   
  return follow_best_incoming( path_id, e->source, path, depth, arg, output_func );  
}

int  write_trajectory( FILE* file, Node* root, int depth, int path_id,
                       int (*follow)(int,Node*,Edge**,int,void*, 
                                     void (*output_func)(void*,Edge**,int,int)) )
{ Edge** path = (Edge**)Guarded_Malloc( depth*sizeof(Edge*) , "write_trajectory"); /* path gets freed in follow func */
  memset( path, 0, depth*sizeof(Edge*) );
  path_id = follow( path_id, root, path, depth, file, output_trajectory_tofile );
  return path_id;
}

double distance_shortest_path(Node *a, Node *b, Node *graph, int sz)
{ Compute_Shortest_Paths( a, graph, sz );
  return b->val;
}

double distance_pairwise(Node *a, Node *b, Node *graph, int sz)
{ double d;
  double ta,tb;
  if( (a->type  == (int) NL_LOST) || (b->type  == (int) NL_LOST)  )
  { 
    if (a->type  == (int) NL_LOST)
      ta = (int) a->data;
    else
      ta = ((Whisker_Seg*) a->data)->time;
    
    if (b->type  == (int) NL_LOST)
      tb = (int) b->data;
    else
      tb = ((Whisker_Seg*) b->data)->time;
    
    if( (tb-ta)<=0 )
      return INFINITY;

    d = LOST_DISTANCE; /*Lost nodes can connect to downstream nodes at const dist */
  } else
  { //printf("%p %p\n",  (Whisker_Seg*)a->data, (Whisker_Seg*)b->data ); 
    d = whisker_distance( (Whisker_Seg*)a->data, (Whisker_Seg*)b->data );
    if( d > DISTANCE_CUTOFF )
      d = INFINITY;
  }
  return d;
}

void   Create_Trajectory_Graph( Whisker_Seg ***wv, int *wv_n, int depth, 
                                int nNodes, Node *graph, Node **offsets)
  /* Makes a graph representing the soluton to the correspondance problem for
   * the input whisker segments, wv.  An edge in the output graph indicates the
   * two associated whisker segments are part of the same whisker.  Initially
   * nothing is connected.
   *
   * Output: 
   *    `graph`   : an array of all the nodes.  The buffer should be
   *                preallocated and made to contain as many nodes as there are
   *                whisker segments.  These nodes refer to the whisker
   *                segments, so try to keep those around.
   *    `offsets` : an  array of pointers addressing nodes in the graph 
   *                that represent the first of several for a frame.  This should be
   *                a preallocated array of length `depth` containing Node*'s.
   *
   * TODO: make helper function for calculating nNodes from wv_n and depth
   */
{ int i,j,iSeg;
  //int nNode = nTotalSegs + depth*LOST_PER_FRAME;
  Init_Node_Array( graph, nNodes );
      
  /* associate whisker segment data with nodes */
  for( i=0, iSeg=0; i < depth; i++ )
  { offsets[i] = graph+iSeg;
    for( j=0; j < wv_n[i]; j++ )
    { graph[iSeg  ].type  = (unsigned int) NL_WHISKER_SEG;
      graph[iSeg++].data = (void*) wv[i][j];
    }
    for( j=0; j < (unsigned int) LOST_PER_FRAME; j++)
    { graph[iSeg  ].type  = (unsigned int) NL_LOST;
      graph[iSeg++].data = (void*) i; // for time data - cast back to (int) - dirty
    }
  }

  return;
}

void Trajectory_Graph_Connect_By_Threshold(int nNodes, Node *graph, Node **offsets, double thresh )
/*
  * Connect all nodes that have distance less than a threshold
  *  - this goes over all frames, so it needs a distance function that
  *    accounts for time
  *  - The threshold may be determined as the smallest distance such that
  *    there is no confidence in the best transition among 
  *    the set of hypothetical transitions with distance (or score)
  *    greater than the threshold.  Confidence is the probability a 
  *    chosen hypothetical transition corresponds to the true transition.
  */
{ Whisker_Seg *cur, *next;
  int i,j;
  double d;
  for( i=0; i<nNodes; i++ )
  { for( j = i+1; j < nNodes; j++)
    { d = distance_pairwise( graph + i, graph + j, graph, nNodes);
      if( d < thresh )         //it'd be nice if this were adaptive as a fn of velocity
          Create_Edge( graph+i, graph+j, d  );
    }
  }
}

void Trajectory_Graph_Local_Bipartite_Matching(int nFirstFrame, int nNodes, Node *graph, Node **offsets)
  /*
   * Local Bipartite matching
   * - full bipartite matching of all nodes to themselves takes too long.
   * - solution is to first limit the graph to reasonable connections
   */
{ 
  Node **sources = (Node**) malloc( nFirstFrame * sizeof(Node*) );
  int i;
  for( i=0; i< nFirstFrame; i++ )
    sources[i] = (Node*) (offsets[0]+i);
  printf("Calculating avoiding paths\n");
  local_best_paths(graph, nNodes, sources, nFirstFrame );
  free(sources);
}

